# How to generate a Light Yield map with the standalone simulation
 
## Introduction

Prompts to run the standalone simulation with the upper part of FD2-VD PDS implemented in Geant4. 
Created by Hamza Amar Es-sghir (IFIC-Valencia) <Hamza.Amar@ific.uv.es> & Sergio Manthey Corchado (CIEMAT-Madrid) <Sergio.manthey@ciemat.es>

## Installation

In order to install the simulation in one of the fermilab nodes, simply clone the repository in your working directory. 

```bash
git clone https://github.com/DUNE/G4_standalone_sim.git
cd G4_standalone_sim/FD2_VD_PDS-FinalDesign
```

## Setup

In order to run the standalone simulation of the FD2-VD PDS, you do not need to setup LArSoft at all. 
The version we have usually used for G4 is `v4_10_3_p03e`, doing the following setup:

```bash
source /grid/fermiapp/products/common/etc/setup 
source /grid/fermiapp/products/dune/setup_dune.sh 
setup cmake v3_13_1
setup root v6_18_02a -q e17:prof
setup geant4 v4_10_3_p03e -q e17:prof 
```

The directory `FD2_VD_PDS-FinalDesign/vdrift_ref/src` contains different parameters within some `.cc` files. Some of them have to be tweaked depending on simulation purposes. The most relevant are listed below:

- **Energy** of photons (Ar or Xe light) in `PrimaryGeneratorAction.cc`  
- **Region where photons are generated** in `PrimaryGeneratorAction.cc`. Photons are randomly generated in the voxel size defined by the limits.  
- **Optical properties** of the geometry or the own geometry in `DetectorConstruction.cc`.

## Compilation

Once finished, compile to obtain the `vdrift_build` directory and the executable, called `g4workshop`. To build this code is recommended to use the following commands:

```bash
cmake -S vdrift_ref -B vdrift_build
cmake --build vdrift_build
```

## Running the simulation

Once done, you just have to type the following command: `./vdrift_build/g4workshop X Y Z`. Coordinates are entered in meters. This will generate a file called `arapuca.root` in the same directory.

In a file `arapuca.root` you should see only 4 histograms; `hdX`, `hdY`, `hdZ`, to study the photon generation uniformity in a voxel, and `hv`. All of them defined in `RunAction.cc`. Other leafs of the tree does not open. The histogram of interest is `hv`(short for *histogram of volumes*) and the volume code associated to different X-ARAPUCAs channels will provide the number of photons reaching them in the simulation (have a look at `SteppingAction.cc`). 

So, to obtain the total *LY* for a given position *(X, Y, Z)* you simply integrate the histogram `hv` multiplying by the correct parameters. We usually run 1 million photons per voxel.

## Grid submission

To obtain enough resolution in your light yield map you may want to simulate . However, it would not be feasible if we do not use the FermiGrid (or the equivalent at CERN). This mpust be done, as you may know, in the `/pnfs/dune/scratch/`directory.

To send jobs to the grid we use to bash scripts:
- `run_loop.sh`.
- `run_point.sh`.

The former allows to execute the latter bash file at position *(X, Y, Z)* by using a loop. With three `for`statements you define the initial and final positions, apart from the steps.  
Regarding `run_point.sh`, it exports the `arapuca_X_Y_Z.root` file to the scratch directory where you executed the bash. To do so, it is mandatory to generate a `tgz` file containing the `vdrift_build` directory at the `scratch`.

A very useful command is `nohup ``your_actual_command`` > out.txt &`. `nohup` permits not to use our own resources to run the bash file. If so, you would have at your disposal the same terminal, or even shut it down without stopping the production!!!  
The `> out.txt` is an optional dumping command. This generates a file `out.txt` containing the output of the command. 

**Remarks:**  
This is not the only way to do that. Feel free to play along to improve the efficiency according to good practices recommended by user grid usage group. In case of doubt we suggest to ask in the *#user_grid_usage* Slack channel.

## *LY* macro

To build the well-known *LY* maps, there is a macro available, called `newlightYield.C`. Depending on the generated `arapuca.root` files, you would be interested in a certain kind of light yield map.  

This macro is intended for *(X,Y)* light yield maps, but it is quite straightforward to modify, if necessary. Have a look at the comments there to orientate yourself.

The lower part of the *LY* map is generated by mirroring over the upper one. This is done under the assumption that no relevant number of photons generated at the top volume would be detected by detectors at the bottom volume.  
